## 추상클래스

추상클래스는 **미완성 설계도**에 비유할 수 있다. 단어의 뜻 그대로 완성되지 못한채로 남겨진 설계도를 말한다. 따라서 인스턴스는 생성할 수 없고 **상속을 통해서 자손클래스에 의해서만 완성**될 수 있다.

추상클래스는 클래스 앞에 키워드 ‘abstract’ 를 통해 선언할 수 있다.

```java
abstract class 클래스이름 {
		...
}
```

추상클래스는 추상 메서드를 포함하고 있다는 것을 제외하고 일반클래스와 다른 부분이 없다.

그래서 추상클래스에도 **생성자**가 있으며, **멤버 변수**와 **메서드**도 가질 수 있다.

**추상메서드**란? 선언부만 작성하고 구현부는 작성하지 않은채로 남겨둔 것을 말한다.

- 실제 내용은 상속받는 클래스에서 구현하도록 비워두는 것이다.
- 그래서 추상클래스에서 상속받은 자손 클래스는 조상의 추상 메서드를 상황에 맞게 적절히 구현해줘야 한다.

```java
/* 주석을 통해 어떤 기능을 수행할 목적으로 작성하였는지 설명한다. */
abstract 리턴타입 메서드이름();

abstract void play(int pos);
abstract void stop();
```

### 추상클래스 작성

- 추상화는 기존의 클래스의 **공통부분**을 뽑아내서 조상 클래스를 만드는 것이라고 할 수 있다.
- 그래서 상속계층도를 따라 내려 갈수록 **세분화**되며, 올라갈수록 **공통요소**만 남게 된다.
    - 추상화: 클래스간의 공통점을 찾아내서 공통의 조상을 만드는 작업
    - 구체화: 상속을 통해 클래스를 구현, 확장하는 작업

굳이 abstract를 붙여서 추상메서드로 선언하는 이유는 자손 클래스에서 추상메서드를 **반드시 구현하도록 강요하기 위해서**이다. 자손 클래스를 작성할 때 이들이 추상메서드이므로 내용을 구현해주어야 한다는 사실을 인식하고 자신의 클래스에 알맞게 구현한 것이다.

정리하면, 각 클래스의 **공통부분**을 뽑아내서 추상클래스를 정의하고 자식클래스들이 추상클래스로부터 상속받도록 한다. 그리고 자식클래스에서 자신의 상황에 맞게 메서드는 반드시 구현해야 한다.

참고로, 모든 클래스의 조상인 **Object 클래스 타입**에서는 개별 추상 메서드가 정의되어 있지 않기 때문에 해당 메서드를 호출하면 **에러가 발생**할 것이다.

## 인터페이스

인터페이스는 일종의 추상클래스이다.

인터페이스란 다른 클래스를 작성할 때 **기본이 되는 틀**을 제공하면서, 다른 클래스 사이의 **중간 매개 역할** 까지 담당하는 일종의 추상 클래스를 의미합니다.

- 추상클래스가 부분적으로만 완성된 ‘**미완성 설계도**’라면
- 인터페이스는 구현된 것은 아무것도 없고 밑그림만 그려져 있는 ‘**기본 설계도**’라 할 수 있다.

추상클래스와 달리 **오직 추상 메서드와 상수만을 멤버로 가질 수 있고**, 그 외에 다른 요소는 허용하지 않는다. (생성자, 필드, 일반 메서드 안됨 ↔ `추상 클래스`는 생성자, 필드, 일반 메서드 가능)

키워드는 ‘interface’이고, (클래스와 같이) 접근제어자는 public 또는 default를 사용할 수 있다.

```java
interface 인터페이스이름 {
		public static final 타입 상수이름 = 값;
		public abstract 메서드이름(매개변수목록);
}
```

일반적인 클래스 멤버들과 달리 인터페이스의 멤버들은 다음과 같은 제약사항이 있다.

- 모든 멤버변수는 public static final 이어야 하며, 이를 생략할 수 있다. (생략하는 경우가 많음)
- 모든 메서드는 public abstract 이어야 하며, 이를 생략할 수 있다. (생략하는 경우가 많음)

### 인터페이스의 상속

- 인터페이스는 클래스와는 달리 **다중 상속, 여러 개의 인터페이스로부터 상속을 받는 것이 가능하다.**
- 여러 개의 인터페이스를 상속할 때 쉼표(,)로 구분해 나열한다.

```java
class 클래스이름 implements 인터페이스명1, 인터페이스2, ..., 인터페이스명 {
		...
}
```

### 인터페이스의 구현

- 인터페이스도 추상클래스처럼 그 자체로는 인스턴스를 생성할 수 없으며, 인터페이스 자신이 정의한 추상메서드의 몸통을 만들어주는 클래스를 작성해야 한다.
- 인터페이스는 **구현한다**는 의미의 키워드 ‘`implements`’를 사용한다. (클래스는 **확장한다**는 의미의 ‘extends’를 사용한다)

```java
class 클래스이름 implements 인터페이스이름 {
		...
}
```

- 만약 구현하는 인터페이스의 메서드 중 **일부만 구현한다면, abstract를 붙여서 추상클래스를 선언**해야 한다.

만약 클래스와 인터페이스를 함께 상속할 때는 아래와 같은 순서로 한다.

```java
class 클래스명 extends 클래스명 implements 인터페이스명, ..., 인터페이스명 {
		...
}
```

- 이때,  클래스는 다중상속이 불가능하기 때문에, `extends`가 `implements`보다 앞에 있어야 한다.

### 인터페이스의 장점

- 대규모 프로젝트 개발 시 **일관되고 정형화된 개발을 위한 표준화가 가능하다.**
    - 프로젝트에 사용되는 기본 틀을 인터페이스로 작성한 다음, 개발자들에게 인터페이스를 구현하여 프로그램을 작성하도록 한다.
- 클래스의 작성과 인터페이스의 구현을 동시에 진행할 수 있으므로, **개발 시간을 단축시킬 수 있다.**
- 클래스와 클래스 간의 관계를 인터페이스로 연결하면, 클래스마다 **독립적인 프로그래밍이 가능하다.**


## 추상클래스와 인터페이스의 공통점

1. 추상 클래스와 인터페이스는 선언만 있고 구현 내용이 없는 클래스이다.
    - 따라서 인터페이스와 추상 클래스를 가지고 **새로운 인스턴스(객체)를 생성할 수 없다.**
2. 상속받은 메서드를 구현하는 자식 클래스만이 객체를 생성할 수 있다.
    - 추상 클래스를 **extends**로 상속받아 구현한 **자식 클래스나**
    - 인터페이스를 **implements**하고 구현한 **자식 클래스만이 객체를 생성할 수 있다.**

(참고로 인터페이스는 일종의 추상클래스이다.)

## Reference

- [Java의 정석](http://www.yes24.com/Product/Goods/24259565)
